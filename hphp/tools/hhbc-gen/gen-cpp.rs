// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the "hack" directory of this source tree.
pub mod shared;

use anyhow::Result;
use std::{fs, io::Read, path::PathBuf};
use structopt::StructOpt;
use syn::{
    Expr, ExprLit, Fields, GenericArgument, Ident, Item, ItemEnum, Lit, Path, PathArguments,
    ReturnType, Type, TypePath,
};

#[derive(StructOpt, Debug)]
#[structopt(no_version)]
pub struct Opts {
    /// Rust file containing opcode enum definition.
    input: PathBuf,
}

/// hphp-gen/gen-cpp.rs
///
/// Read a Rust `enum Op` enum generated by gen-rust.cpp (using Syn),
/// then generate a C++ OPCODES macro definition that should perfectly
/// match the original one from hhbc.h, except whitespace.
///
/// This is just a demo to hand-check that we haven't lost any information
/// in the round trip. It also serves as an example that could be used
/// as the basis for one or more Rust proc-macros.
fn main() -> Result<()> {
    let opts = Opts::from_args();
    let mut file = fs::File::open(&opts.input)?;
    let mut src = String::new();
    file.read_to_string(&mut src)?;
    let file = syn::parse_file(&src)?;
    for item in file.items {
        match item {
            Item::Enum(e) if e.ident == "Op" => {
                print_op(&e);
            }
            _ => {}
        }
    }

    Ok(())
}

fn print_op(e: &ItemEnum) {
    println!("#define OPCODES \\");
    for v in e.variants.iter() {
        let mut imm: Vec<&Path> = Default::default();
        let mut inputs: Vec<&Path> = Default::default();
        let mut outputs: Vec<&Path> = Default::default();
        let mut flag = "NF";
        match &v.fields {
            Fields::Named(f) => unimplemented!("{:#?}", f),
            Fields::Unnamed(f) => {
                for f in f.unnamed.iter() {
                    match &f.ty {
                        Type::Array(a) => {
                            // expecting a BareFn type
                            match &*a.elem {
                                Type::BareFn(f) => {
                                    for arg in f.inputs.iter() {
                                        inputs.push(type_path(&arg.ty));
                                    }
                                    match &f.output {
                                        ReturnType::Default => {}
                                        ReturnType::Type(_, t) => match &**t {
                                            Type::Path(_) => outputs.push(type_path(t)),
                                            Type::Tuple(tup) => {
                                                for t in tup.elems.iter() {
                                                    outputs.push(type_path(t));
                                                }
                                            }
                                            x => unimplemented!("{:#?}", x),
                                        },
                                    }
                                }
                                x => unimplemented!("{:#?}", x),
                            }
                        }
                        Type::Path(TypePath { path, .. }) => {
                            match path.segments[0].ident.to_string().as_str() {
                                "CF" => flag = "CF",
                                "TF" => flag = "TF",
                                "CF_TF" => flag = "CF_TF",
                                _ => imm.push(path),
                            }
                        }
                        x => unimplemented!("{:#?}", x),
                    }
                }
            }
            Fields::Unit => {}
        };
        println!(
            "  O({:20} {:20} {:20} {:20} {}) \\",
            format!("{},", v.ident),
            fmt_tuple(&imm, "NA"),
            fmt_tuple(&inputs, "NOV"),
            fmt_tuple(&outputs, "NOV"),
            flag
        );
    }
}

/// Pull the Path out of a TypePath. In general these could have
/// module qualifiers (e.g. `my_mod::Foo` but we only expect
/// unqualified type names.
fn type_path(t: &Type) -> &Path {
    match t {
        Type::Path(TypePath { path, .. }) => path,
        x => unimplemented!("{:#?}", x),
    }
}

/// Print an imm or input/output macro, e.g. ONE(LA), TWO(CV,CV), but
/// handle special cases that don't use the ONE/TWO/THREE macros.
fn fmt_tuple(paths: &[&Path], empty: &str) -> String {
    if paths.is_empty() {
        return format!("{},", empty);
    }
    let first = fmt_path(paths[0]);
    match first.as_str() {
        "SMANY" | "CMANY" | "CUMANY" | "MFINAL" | "C_MFINAL" => {
            return format!("{},", first);
        }
        s if s.starts_with("FCALL") => {
            return format!("{},", first);
        }
        _ => {}
    }
    let words = ["", "ONE", "TWO", "THREE", "FOUR"];
    format!(
        "{}({}),",
        words[paths.len()],
        paths
            .iter()
            .map(|&path| fmt_path(path))
            .collect::<Vec<_>>()
            .join(",")
    )
}

/// Format types:
/// Plain types are unmodified.
/// Format a generic type, e.g. OA<IncDecOp> using parens: OA(IncDecOp)
/// or FCIN<1,2> as FCALL(1,2).
fn fmt_path(path: &Path) -> String {
    let segment = &path.segments[0];
    match &segment.arguments {
        PathArguments::None => fmt_id(&segment.ident),
        PathArguments::AngleBracketed(a) => {
            format!(
                "{}({})",
                fmt_id(&segment.ident),
                a.args
                    .iter()
                    .map(|ga| {
                        match ga {
                            GenericArgument::Type(t) => fmt_path(type_path(t)),
                            GenericArgument::Const(e) => match e {
                                Expr::Lit(ExprLit {
                                    lit: Lit::Int(n), ..
                                }) => n.to_string(),
                                x => unimplemented!("{:#?}", x),
                            },
                            x => unimplemented!("{:#?}", x),
                        }
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        }
        x => unimplemented!("{:#?}", x),
    }
}

/// turn FCIN/OUT back to FCALL. This wouldn't be necessary
/// if we used FCALL consistently with or without parens, or
/// if we split FCALL into FCIN/FCOUT in the original OPCODES macro.
fn fmt_id(id: &Ident) -> String {
    let id = id.to_string();
    match id.as_str() {
        "FCIN" | "FCOUT" => "FCALL".into(),
        _ => id,
    }
}
