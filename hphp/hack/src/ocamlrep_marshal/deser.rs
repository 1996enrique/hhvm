// Initially generated by c2rust of 'intern.c' at revision
// `15553b77175270d987058b386d737ccb939e8d5a` (that is, the 4.14.0 tag).
//
// We tried generating it from `f14c8ff3f8a164685bc24184fba84904391e378e` as
// 'extern.c' was but that proved to be quite incompatible with the 4.14.0
// runtime.

#![allow(
    clippy::upper_case_acronyms,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_variables
)]

use libc::c_char;
use libc::c_double;
use libc::c_int;
use libc::c_long;
use libc::c_schar;
use libc::c_short;
use libc::c_uchar;
use libc::c_uint;
use libc::c_ulong;
use libc::c_ushort;
use libc::c_void;
use libc::memcpy;
use libc::snprintf;

use crate::intext::*;

extern "C" {

    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type mark_stack;

    static mut caml_allocated_words: uintnat;
    static mut Caml_state: *mut caml_domain_state;
    static mut caml_atom_table: *mut header_t;
    static mut caml_fl_p_make_free_blocks:
        Option<unsafe extern "C" fn(_: *mut value, _: mlsize_t, _: c_int, _: c_int) -> ()>;

    fn caml_memprof_track_interned(block: *mut header_t, blockend: *mut header_t);
    fn caml_process_pending_actions();
    fn caml_alloc_shr_no_track_noexc(_: mlsize_t, _: tag_t) -> value;
    fn caml_allocation_color(hp: *mut c_void) -> color_t;
    fn caml_alloc_for_heap(request: asize_t) -> *mut c_char;
    fn caml_free_for_heap(mem: *mut c_char);
    fn caml_add_to_heap(mem: *mut c_char) -> c_int;
    fn caml_failwith(msg: *const c_char) -> !;
    fn caml_invalid_argument(msg: *const c_char) -> !;
    fn caml_stat_alloc_noexc(_: asize_t) -> caml_stat_block;
    fn caml_raise_out_of_memory() -> !;
    fn caml_stat_free(_: caml_stat_block);
    fn caml_stat_resize_noexc(_: caml_stat_block, _: asize_t) -> caml_stat_block;
    fn caml_alloc_small_dispatch(_: intnat, _: c_int, _: c_int, _: *mut c_uchar);
    fn caml_string_length(_: value) -> mlsize_t;
    fn caml_set_oo_id(obj: value) -> value;
    fn caml_gc_message(_: c_int, _: *const c_char, _: ...);
}

pub type size_t = c_ulong;
pub type __int16_t = c_short;
pub type __uint16_t = c_ushort;
pub type __int32_t = c_int;
pub type __uint32_t = c_uint;
pub type __int64_t = c_long;
pub type __uint64_t = c_ulong;
pub type __off_t = c_long;
pub type __off64_t = c_long;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: c_int,
    pub _IO_read_ptr: *mut c_char,
    pub _IO_read_end: *mut c_char,
    pub _IO_read_base: *mut c_char,
    pub _IO_write_base: *mut c_char,
    pub _IO_write_ptr: *mut c_char,
    pub _IO_write_end: *mut c_char,
    pub _IO_buf_base: *mut c_char,
    pub _IO_buf_end: *mut c_char,
    pub _IO_save_base: *mut c_char,
    pub _IO_backup_base: *mut c_char,
    pub _IO_save_end: *mut c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: c_int,
    pub _flags2: c_int,
    pub _old_offset: __off_t,
    pub _cur_column: c_ushort,
    pub _vtable_offset: c_schar,
    pub _shortbuf: [c_char; 1],
    pub _lock: *mut c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut c_void,
    pub __pad5: size_t,
    pub _mode: c_int,
    pub _unused2: [c_char; 20],
}

pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type intnat = c_long;
pub type uintnat = c_ulong;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sigset_t {
    pub __val: [c_ulong; 16],
}

type asize_t = size_t;
type backtrace_slot = *mut c_void;
type value = intnat;
type header_t = uintnat;
type mlsize_t = uintnat;
type tag_t = c_uint;
type color_t = uintnat;
type extra_params_area = [value; 64];

#[derive(Copy, Clone)]
#[repr(C)]
struct caml_domain_state {
    pub _young_limit: *mut value,
    pub _young_ptr: *mut value,
    pub _exception_pointer: *mut c_char,
    pub _young_base: *mut c_void,
    pub _young_start: *mut value,
    pub _young_end: *mut value,
    pub _young_alloc_start: *mut value,
    pub _young_alloc_end: *mut value,
    pub _young_alloc_mid: *mut value,
    pub _young_trigger: *mut value,
    pub _minor_heap_wsz: asize_t,
    pub _in_minor_collection: intnat,
    pub _extra_heap_resources_minor: c_double,
    pub _ref_table: *mut caml_ref_table,
    pub _ephe_ref_table: *mut caml_ephe_ref_table,
    pub _custom_table: *mut caml_custom_table,
    pub _mark_stack: *mut mark_stack,
    pub _stack_low: *mut value,
    pub _stack_high: *mut value,
    pub _stack_threshold: *mut value,
    pub _extern_sp: *mut value,
    pub _trapsp: *mut value,
    pub _trap_barrier: *mut value,
    pub _external_raise: *mut longjmp_buffer,
    pub _exn_bucket: value,
    pub _top_of_stack: *mut c_char,
    pub _bottom_of_stack: *mut c_char,
    pub _last_return_address: uintnat,
    pub _gc_regs: *mut value,
    pub _backtrace_active: intnat,
    pub _backtrace_pos: intnat,
    pub _backtrace_buffer: *mut backtrace_slot,
    pub _backtrace_last_exn: value,
    pub _compare_unordered: intnat,
    pub _requested_major_slice: intnat,
    pub _requested_minor_gc: intnat,
    pub _local_roots: *mut caml__roots_block,
    pub _stat_minor_words: c_double,
    pub _stat_promoted_words: c_double,
    pub _stat_major_words: c_double,
    pub _stat_minor_collections: intnat,
    pub _stat_major_collections: intnat,
    pub _stat_heap_wsz: intnat,
    pub _stat_top_heap_wsz: intnat,
    pub _stat_compactions: intnat,
    pub _stat_forced_major_collections: intnat,
    pub _stat_heap_chunks: intnat,
    pub _eventlog_startup_timestamp: uintnat,
    pub _eventlog_startup_pid: c_long,
    pub _eventlog_paused: uintnat,
    pub _eventlog_enabled: uintnat,
    pub _eventlog_out: *mut FILE,
    pub _extra_params: extra_params_area,
}

#[derive(Copy, Clone)]
#[repr(C)]
struct caml__roots_block {
    pub next: *mut caml__roots_block,
    pub ntables: intnat,
    pub nitems: intnat,
    pub tables: [*mut value; 5],
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct longjmp_buffer {
    pub buf: sigjmp_buf,
}

pub type sigjmp_buf = [__jmp_buf_tag; 1];

#[derive(Copy, Clone)]
#[repr(C)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: c_int,
    pub __saved_mask: __sigset_t,
}
pub type __jmp_buf = [c_long; 8];

#[derive(Copy, Clone)]
#[repr(C)]
pub struct caml_custom_table {
    pub base: *mut caml_custom_elt,
    pub end: *mut caml_custom_elt,
    pub threshold: *mut caml_custom_elt,
    pub ptr: *mut caml_custom_elt,
    pub limit: *mut caml_custom_elt,
    pub size: asize_t,
    pub reserve: asize_t,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct caml_custom_elt {
    pub block: value,
    pub mem: mlsize_t,
    pub max: mlsize_t,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct caml_ephe_ref_table {
    pub base: *mut caml_ephe_ref_elt,
    pub end: *mut caml_ephe_ref_elt,
    pub threshold: *mut caml_ephe_ref_elt,
    pub ptr: *mut caml_ephe_ref_elt,
    pub limit: *mut caml_ephe_ref_elt,
    pub size: asize_t,
    pub reserve: asize_t,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct caml_ephe_ref_elt {
    pub ephe: value,
    pub offset: mlsize_t,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct caml_ref_table {
    pub base: *mut *mut value,
    pub end: *mut *mut value,
    pub threshold: *mut *mut value,
    pub ptr: *mut *mut value,
    pub limit: *mut *mut value,
    pub size: asize_t,
    pub reserve: asize_t,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct custom_operations {
    pub identifier: *const c_char,
    pub finalize: Option<unsafe extern "C" fn(_: value) -> ()>,
    pub compare: Option<unsafe extern "C" fn(_: value, _: value) -> c_int>,
    pub hash: Option<unsafe extern "C" fn(_: value) -> intnat>,
    pub serialize: Option<unsafe extern "C" fn(_: value, _: *mut uintnat, _: *mut uintnat) -> ()>,
    pub deserialize: Option<unsafe extern "C" fn(_: *mut c_void) -> uintnat>,
    pub compare_ext: Option<unsafe extern "C" fn(_: value, _: value) -> c_int>,
    pub fixed_length: *const custom_fixed_length,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct custom_fixed_length {
    pub bsize_32: intnat,
    pub bsize_64: intnat,
}

pub type digest_status = c_uint;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct code_fragment {
    pub code_start: *mut c_char,
    pub code_end: *mut c_char,
    pub fragnum: c_int,
    pub digest: [c_uchar; 16],
    pub digest_status: digest_status,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct marshal_header {
    pub magic: uint32_t,
    pub header_len: c_int,
    pub data_len: uintnat,
    pub num_objects: uintnat,
    pub whsize: uintnat,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct intern_item {
    pub dest: *mut value,
    pub arg: intnat,
    pub op: c_uint,
}
pub const OReadItems: c_uint = 0; // read arg items and store them in dest[0], dest[1], ...
pub const OFreshOID: c_uint = 1; // generate a fresh OID and store it in *dest
pub const OShift: c_uint = 2; // offset *dest by arg

pub type caml_stat_block = *mut c_void;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct heap_chunk_head {
    pub block: *mut c_void,
    pub allocated: asize_t,
    pub size: asize_t,
    pub next: *mut c_char,
    pub redarken_first: mark_entry,
    pub redarken_end: *mut value,
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct mark_entry {
    pub start: *mut value,
    pub end: *mut value,
}

pub const CAML_FROM_C: caml_alloc_small_flags = 0;
pub const CAML_DONT_TRACK: caml_alloc_small_flags = 0;
pub type caml_alloc_small_flags = c_uint;

const Caml_white: c_int = (0 as c_int) << 8 as c_int;
const Caml_black: c_int = (3 as c_int) << 8 as c_int;

// ---
#[inline]
const unsafe fn Hd_val(v: value) -> header_t {
    *(v as *const header_t).offset(-1)
}
#[inline]
unsafe fn Hd_val_set(v: value, h: header_t) {
    *(v as *mut header_t).offset(-1) = h;
}
//#define Hp_val(val) (((header_t *) (val)) - 1)
#[inline]
unsafe fn Hp_val(v: value) -> *mut header_t {
    (v as *mut header_t).offset(-(1 as c_int as isize))
}
#[inline]
const fn Color_hd(hd: header_t) -> c_ulong {
    hd & (Caml_black as c_ulong)
}
#[inline]
const fn Val_long(x: value) -> c_long {
    (((x as uintnat) << 1) + 1 as uintnat) as c_long
}
#[inline]
const fn Val_int(x: value) -> c_long {
    Val_long(x)
}
#[inline]
const fn Long_val(x: value) -> intnat {
    x >> 1
}
#[inline]
unsafe fn Val_hp(hp: *mut header_t) -> value {
    hp.offset(1) as value
}
#[inline]
unsafe fn Atom(tag: isize) -> value {
    Val_hp(caml_atom_table.offset(tag))
}
/// Fields are numbered from 0.
#[inline]
const unsafe fn Field(x: value, i: usize) -> value {
    *(x as *const value).add(i)
}
#[inline]
unsafe fn Field_ptr_mut(x: value, i: usize) -> *mut value {
    &mut *(x as *mut value).add(i) as *mut value
}

#[inline]
unsafe fn Byte_ptr_mut(x: value, i: usize) -> *mut c_char {
    &mut *(x as *mut c_char).add(i) as *mut c_char
}
#[inline]
unsafe fn Byte_u_ptr_mut(x: value, i: usize) -> *mut c_uchar {
    &mut *(x as *mut c_uchar).add(i) as *mut c_uchar
}

#[inline]
const fn Wosize_whsize(size: mlsize_t) -> mlsize_t {
    size.wrapping_sub(1)
}

#[inline]
const fn Bsize_wsize(size: u64) -> u64 {
    size.wrapping_mul(std::mem::size_of::<value>() as u64)
}

#[inline]
const fn Wsize_bsize(size: u64) -> u64 {
    size.wrapping_div(std::mem::size_of::<value>() as u64)
}

#[inline]
const fn Make_header(wosize: mlsize_t, tag: tag_t, color: color_t) -> header_t {
    (wosize << 10)
        .wrapping_add(color as header_t)
        .wrapping_add(tag as header_t)
}

const Double_wosize: c_ulong = (std::mem::size_of::<c_double>() as c_ulong)
    .wrapping_div(std::mem::size_of::<value>() as c_ulong);

const Object_tag: c_uint = 248;
const String_tag: c_uint = 252;
const Double_tag: c_uint = 253;
const Double_array_tag: c_uint = 254;

const Max_wosize: c_ulong =
    (((1 as c_int as intnat) << 54 as c_int) - 1 as c_int as c_long) as c_ulong;

const Page_log: c_ulong = 12; // A page is 4 kilobytes
const Page_size: c_ulong = ((1 as c_int) << Page_log as c_int) as c_ulong;

// Maximum size of a block allocated in the young generation (words).
// Must be > 4
const Max_young_wosize: c_ulong = 256;

#[inline]
unsafe fn make_free_blocks(p: *mut value, size: mlsize_t, do_merge: c_int, color: c_int) {
    // `caml_fl_p_make_free_blocks` is an externally linked item defined in
    // 'free_list.c'.
    Some(caml_fl_p_make_free_blocks.expect("non-null function pointer"))
        .expect("non-null function pointer")(p, size, do_merge, color);
}

unsafe fn Reverse_64(dest: *mut c_char, src: *mut c_char) {
    let mut _p: *mut c_char = std::ptr::null_mut::<c_char>();
    let mut _q: *mut c_char = std::ptr::null_mut::<c_char>();
    let mut _a: c_char = 0;
    let mut _b: c_char = 0;
    _p = dest as *mut c_char;
    _q = dest as *mut c_char;
    _a = *_p.offset(0 as c_int as isize);
    _b = *_p.offset(1 as c_int as isize);
    *_q.offset(0 as c_int as isize) = *_p.offset(7 as c_int as isize);
    *_q.offset(1 as c_int as isize) = *_p.offset(6 as c_int as isize);
    *_q.offset(7 as c_int as isize) = _a;
    *_q.offset(6 as c_int as isize) = _b;
    _a = *_p.offset(2 as c_int as isize);
    _b = *_p.offset(3 as c_int as isize);
    *_q.offset(2 as c_int as isize) = *_p.offset(5 as c_int as isize);
    *_q.offset(3 as c_int as isize) = *_p.offset(4 as c_int as isize);
    *_q.offset(5 as c_int as isize) = _a;
    *_q.offset(4 as c_int as isize) = _b
}

// ---

static mut intern_src: *mut c_uchar = std::ptr::null_mut::<c_uchar>();
// Reading pointer in block holding input data.

static mut intern_input: *mut c_uchar = 0 as *const c_uchar as *mut c_uchar;
// Pointer to beginning of block holding input data, if non-NULL this pointer
// will be freed by the cleanup function.

static mut intern_dest: *mut header_t = 0 as *const header_t as *mut header_t;
// Writing pointer in destination block

static mut intern_extra_block: *mut c_char = 0 as *const c_char as *mut c_char;
// If non-NULL, point to new heap chunk allocated with caml_alloc_for_heap.

static mut obj_counter: asize_t = 0;
// Count how many objects seen so far

static mut intern_obj_table: *mut value = 0 as *const value as *mut value;
// The pointers to objects already seen

static mut intern_color: color_t = 0;
// Color to assign to newly created headers

static mut intern_header: header_t = 0;
// Original header of the destination block. Meaningful only if
// intern_extra_block is NULL.

static mut intern_block: value = 0 as c_int as value;
// Point to the heap block allocated as destination block. Meaningful only if
// intern_extra_block is NULL.

#[inline]
unsafe fn read8u() -> c_uchar {
    let fresh0 = intern_src;
    intern_src = intern_src.offset(1);
    *fresh0
}

#[inline]
unsafe fn read8s() -> c_schar {
    let fresh1 = intern_src;
    intern_src = intern_src.offset(1);
    *fresh1 as c_schar
}

#[inline]
unsafe fn read16u() -> uint16_t {
    let res: uint16_t = (((*intern_src.offset(0 as c_int as isize) as c_int) << 8 as c_int)
        + *intern_src.offset(1 as c_int as isize) as c_int) as uint16_t;
    intern_src = intern_src.offset(2 as c_int as isize);
    res
}

#[inline]
unsafe fn read16s() -> int16_t {
    let res: int16_t = (((*intern_src.offset(0 as c_int as isize) as c_int) << 8 as c_int)
        + *intern_src.offset(1 as c_int as isize) as c_int) as int16_t;
    intern_src = intern_src.offset(2 as c_int as isize);
    res
}

#[inline]
unsafe fn read32u() -> uint32_t {
    let res: uint32_t = ((*intern_src.offset(0 as c_int as isize) as uint32_t) << 24 as c_int)
        .wrapping_add(((*intern_src.offset(1 as c_int as isize) as c_int) << 16 as c_int) as c_uint)
        .wrapping_add(((*intern_src.offset(2 as c_int as isize) as c_int) << 8 as c_int) as c_uint)
        .wrapping_add(*intern_src.offset(3 as c_int as isize) as c_uint);
    intern_src = intern_src.offset(4 as c_int as isize);
    res
}

#[inline]
unsafe fn read32s() -> int32_t {
    let res: int32_t = ((*intern_src.offset(0 as c_int as isize) as uint32_t) << 24 as c_int)
        .wrapping_add(((*intern_src.offset(1 as c_int as isize) as c_int) << 16 as c_int) as c_uint)
        .wrapping_add(((*intern_src.offset(2 as c_int as isize) as c_int) << 8 as c_int) as c_uint)
        .wrapping_add(*intern_src.offset(3 as c_int as isize) as c_uint)
        as int32_t;
    intern_src = intern_src.offset(4 as c_int as isize);
    res
}

unsafe fn read64u() -> uintnat {
    let res: uintnat = ((*intern_src.offset(0 as c_int as isize) as uintnat) << 56 as c_int)
        .wrapping_add((*intern_src.offset(1 as c_int as isize) as uintnat) << 48 as c_int)
        .wrapping_add((*intern_src.offset(2 as c_int as isize) as uintnat) << 40 as c_int)
        .wrapping_add((*intern_src.offset(3 as c_int as isize) as uintnat) << 32 as c_int)
        .wrapping_add((*intern_src.offset(4 as c_int as isize) as uintnat) << 24 as c_int)
        .wrapping_add((*intern_src.offset(5 as c_int as isize) as uintnat) << 16 as c_int)
        .wrapping_add((*intern_src.offset(6 as c_int as isize) as uintnat) << 8 as c_int)
        .wrapping_add(*intern_src.offset(7 as c_int as isize) as uintnat);
    intern_src = intern_src.offset(8 as c_int as isize);
    res
}

#[inline]
unsafe fn readblock(dest: *mut c_void, len: intnat) {
    memcpy(dest, intern_src as *const c_void, len as usize);
    intern_src = intern_src.offset(len as isize);
}

unsafe fn intern_init(src: *mut c_void, input: *mut c_void) {
    // This is asserted at the beginning of demarshaling primitives. If it fails,
    // it probably means that an exception was raised without calling
    // intern_cleanup() during the previous demarshaling.

    intern_src = src as *mut c_uchar;
    intern_input = input as *mut c_uchar;
}

unsafe fn intern_cleanup() {
    if !intern_input.is_null() {
        caml_stat_free(intern_input as caml_stat_block);
        intern_input = std::ptr::null_mut::<c_uchar>();
    }
    if !intern_obj_table.is_null() {
        caml_stat_free(intern_obj_table as caml_stat_block);
        intern_obj_table = std::ptr::null_mut::<value>();
    }
    if !intern_extra_block.is_null() {
        // free newly allocated heap chunk
        caml_free_for_heap(intern_extra_block);
        intern_extra_block = std::ptr::null_mut::<c_char>();
    } else if intern_block != 0 as c_int as c_long {
        // restore original header for heap block, otherwise GC is confused
        Hd_val_set(intern_block, intern_header);
        intern_block = 0 as value;
    }
    // free the recursion stack
    intern_free_stack();
}

unsafe fn readfloat(dest: *mut c_double, code: c_uint) {
    if std::mem::size_of::<c_double>() != 8 {
        intern_cleanup();
        caml_invalid_argument(
            b"input_value: non-standard floats\x00" as *const u8 as *const c_char,
        );
    }
    readblock(dest as *mut c_char as *mut c_void, 8 as c_int as intnat);

    // Fix up endianness, if needed
    if ARCH_FLOAT_ENDIANNESS == 0x76543210 {
        // Host is big-endian; fix up if data read is little-endian
        if code != CODE_DOUBLE_BIG as c_uint {
            Reverse_64(dest as *mut c_char, dest as *mut c_char)
        }
    } else if ARCH_FLOAT_ENDIANNESS == 0x01234567 {
        // Host is little-endian; fix up if data read is big-endian
        if code != CODE_DOUBLE_LITTLE as c_uint {
            Reverse_64(dest as *mut c_char, dest as *mut c_char)
        };
    } else {
        unimplemented!()
    }
}

// `len` is a number of floats
unsafe extern "C" fn readfloats(dest: *mut c_double, len: mlsize_t, code: c_uint) {
    let mut i: mlsize_t = 0;
    if std::mem::size_of::<c_double>() as c_ulong != 8 as c_int as c_ulong {
        intern_cleanup();
        caml_invalid_argument(
            b"input_value: non-standard floats\x00" as *const u8 as *const c_char,
        );
    }
    readblock(
        dest as *mut c_char as *mut c_void,
        len.wrapping_mul(8 as c_int as c_ulong) as intnat,
    );
    // Fix up endianness, if needed
    if ARCH_FLOAT_ENDIANNESS == 0x76543210 {
        // Host is big-endian; fix up if data read is little-endian
        if code != CODE_DOUBLE_ARRAY8_BIG as c_int as c_uint
            && code != CODE_DOUBLE_ARRAY32_BIG as c_int as c_uint
        {
            i = 0 as c_int as mlsize_t;
            while i < len {
                Reverse_64(
                    dest.offset(i as isize) as *mut c_char,
                    dest.offset(i as isize) as *mut c_char,
                );
                i = i.wrapping_add(1)
            }
        }
    } else if ARCH_FLOAT_ENDIANNESS == 0x01234567 {
        // Host is little-endian; fix up if data read is big-endian
        if code != CODE_DOUBLE_ARRAY8_LITTLE as c_int as c_uint
            && code != CODE_DOUBLE_ARRAY32_LITTLE as c_int as c_uint
        {
            i = 0 as c_int as mlsize_t;
            while i < len {
                Reverse_64(
                    dest.offset(i as isize) as *mut c_char,
                    dest.offset(i as isize) as *mut c_char,
                );
                i = i.wrapping_add(1)
            }
        }
    } else {
        unimplemented!()
    }
}

const INTERN_STACK_INIT_SIZE: usize = 256;
const INTERN_STACK_MAX_SIZE: usize = 1024 * 1024 * 100;

static mut intern_stack_init: [intern_item; INTERN_STACK_INIT_SIZE] = [intern_item {
    dest: std::ptr::null_mut::<value>(),
    arg: 0,
    op: OReadItems,
}; INTERN_STACK_INIT_SIZE];

static mut intern_stack: *mut intern_item = unsafe { intern_stack_init.as_ptr() as *mut _ };
// Initialized in `run_static_initializers`
static mut intern_stack_limit: *mut intern_item = std::ptr::null_mut::<intern_item>();
unsafe extern "C" fn run_static_initializers() {
    intern_stack_limit = intern_stack_init.as_mut_ptr().add(INTERN_STACK_INIT_SIZE)
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];

// Free the recursion stack if needed
unsafe fn intern_free_stack() {
    if intern_stack != intern_stack_init.as_mut_ptr() {
        caml_stat_free(intern_stack as caml_stat_block);
        intern_stack = intern_stack_init.as_mut_ptr();
        intern_stack_limit = intern_stack.offset(256 as c_int as isize)
    };
}

// Same, then raise `Out_of_memory`
unsafe fn intern_stack_overflow() -> ! {
    caml_gc_message(
        0x4 as c_int,
        b"Stack overflow in un-marshaling value\n\x00" as *const u8 as *const c_char as *mut c_char,
    );
    intern_free_stack();
    caml_raise_out_of_memory();
}

unsafe fn intern_resize_stack(sp: *mut intern_item) -> *mut intern_item {
    let newsize: asize_t = (2 * intern_stack_limit.offset_from(intern_stack) as c_long) as asize_t;
    let sp_offset: asize_t = sp.offset_from(intern_stack) as c_long as asize_t;
    let mut newstack: *mut intern_item = std::ptr::null_mut::<intern_item>();

    if newsize >= INTERN_STACK_MAX_SIZE as c_ulong {
        intern_stack_overflow();
    }

    if intern_stack == intern_stack_init.as_mut_ptr() {
        newstack = caml_stat_alloc_noexc(
            (std::mem::size_of::<intern_item>() as c_ulong).wrapping_mul(newsize),
        ) as *mut intern_item;
        if newstack.is_null() {
            intern_stack_overflow();
        }
        memcpy(
            newstack as *mut c_void,
            intern_stack_init.as_mut_ptr() as *const c_void,
            (std::mem::size_of::<intern_item>() as c_ulong)
                .wrapping_mul(INTERN_STACK_INIT_SIZE as c_int as c_ulong) as usize,
        );
    } else {
        newstack = caml_stat_resize_noexc(
            intern_stack as caml_stat_block,
            (std::mem::size_of::<intern_item>() as c_ulong).wrapping_mul(newsize),
        ) as *mut intern_item;
        if newstack.is_null() {
            intern_stack_overflow();
        }
    }
    intern_stack = newstack;
    intern_stack_limit = newstack.offset(newsize as isize);

    newstack.offset(sp_offset as isize)
}

// Convenience functions for requesting operation on the stack
unsafe fn PushItem(mut sp: *mut intern_item) -> *mut intern_item {
    sp = sp.offset(1);
    if sp >= intern_stack_limit {
        sp = intern_resize_stack(sp);
    }
    sp
}
unsafe fn ReadItems(dest: *mut value, n: intnat, mut sp: *mut intern_item) -> *mut intern_item {
    if n > 0 {
        sp = PushItem(sp);
        (*sp).op = OReadItems;
        (*sp).dest = dest;
        (*sp).arg = n;
    }
    sp
}

const READ_BLOCK_LABEL: u64 = 16649699497103515194;
const READ_STRING_LABEL: u64 = 11970676656440271524;
const READ_SHARED_LABEL: u64 = 8656139126282042408;
const READ_DOUBLE_ARRAY_LABEL: u64 = 8966088013221564425;
const NOTHING_TO_DO_LABEL: u64 = 8288085890650723895;

unsafe fn intern_rec(mut dest: *mut value) {
    let mut current_block: u64;
    let mut code: c_uint = 0;
    let mut tag: tag_t = 0;
    let mut size: mlsize_t = 0;
    let mut len: mlsize_t = 0;
    let mut ofs_ind: mlsize_t = 0;
    let mut v: value = 0;
    let mut ofs: asize_t = 0;
    let mut header: header_t = 0;
    let mut sp: *mut intern_item = std::ptr::null_mut::<intern_item>();

    sp = intern_stack;

    // Initially let's try to read the first object from the stream
    sp = ReadItems(dest, 1, sp);

    // The un-marshaler loop, the recursion is unrolled
    while sp != intern_stack {
        // Interpret next item on the stack

        dest = (*sp).dest;
        match (*sp).op as c_uint {
            OFreshOID => {
                if Long_val(Field(dest as value, 1)) >= 0 {
                    caml_set_oo_id(dest as value);
                }
                // Pop item and iterate
                sp = sp.offset(-1)
            }
            OShift => {
                // Shift value by an offset
                *dest += (*sp).arg;
                // Pop item and iterate
                sp = sp.offset(-1)
            }
            OReadItems => {
                // Pop item
                (*sp).dest = (*sp).dest.offset(1);
                (*sp).arg -= 1;
                if (*sp).arg == 0 as c_int as c_long {
                    sp = sp.offset(-1)
                }
                // Read a value and set v to this value
                code = read8u() as c_uint;
                if code >= PREFIX_SMALL_INT as c_int as c_uint {
                    if code >= PREFIX_SMALL_BLOCK as c_int as c_uint {
                        // Small block
                        tag = code & 0xf as c_int as c_uint;
                        size = (code >> 4 as c_int & 0x7 as c_int as c_uint) as mlsize_t;
                        current_block = READ_BLOCK_LABEL;
                    } else {
                        // Small integer
                        v = Val_int((code & 0x3F as c_int as c_uint) as value);
                        current_block = NOTHING_TO_DO_LABEL;
                    }
                } else {
                    if code >= PREFIX_SMALL_STRING as c_int as c_uint {
                        // Small string
                        len = (code & 0x1f as c_int as c_uint) as mlsize_t;
                        current_block = READ_STRING_LABEL;
                    } else {
                        match code as i32 {
                            CODE_INT8 => {
                                v = ((read8s() as uintnat) << 1 as c_int) as intnat
                                    + 1 as c_int as c_long;
                                current_block = NOTHING_TO_DO_LABEL;
                            }
                            CODE_INT16 => {
                                v = ((read16s() as uintnat) << 1 as c_int) as intnat
                                    + 1 as c_int as c_long;
                                current_block = NOTHING_TO_DO_LABEL;
                            }
                            CODE_INT32 => {
                                v = ((read32s() as uintnat) << 1 as c_int) as intnat
                                    + 1 as c_int as c_long;
                                current_block = NOTHING_TO_DO_LABEL;
                            }
                            CODE_INT64 => {
                                v = ((read64u() as intnat as uintnat) << 1 as c_int) as intnat
                                    + 1 as c_int as c_long;
                                current_block = NOTHING_TO_DO_LABEL;
                            }
                            CODE_SHARED8 => {
                                ofs = read8u() as asize_t;
                                current_block = READ_SHARED_LABEL;
                            }
                            CODE_SHARED16 => {
                                ofs = read16u() as asize_t;
                                current_block = READ_SHARED_LABEL;
                            }
                            CODE_SHARED32 => {
                                ofs = read32u() as asize_t;
                                current_block = READ_SHARED_LABEL;
                            }
                            CODE_SHARED64 => {
                                ofs = read64u();
                                current_block = READ_SHARED_LABEL;
                            }
                            CODE_BLOCK32 => {
                                header = read32u() as header_t;
                                tag = (header & 0xff as c_int as c_ulong) as tag_t;
                                size = header >> 10 as c_int;
                                current_block = READ_BLOCK_LABEL;
                            }
                            CODE_BLOCK64 => {
                                header = read64u();
                                tag = (header & 0xff as c_int as c_ulong) as tag_t;
                                size = header >> 10 as c_int;
                                current_block = READ_BLOCK_LABEL;
                            }
                            CODE_STRING8 => {
                                len = read8u() as mlsize_t;
                                current_block = READ_STRING_LABEL;
                            }
                            CODE_STRING32 => {
                                len = read32u() as mlsize_t;
                                current_block = READ_STRING_LABEL;
                            }
                            CODE_STRING64 => {
                                len = read64u();
                                current_block = READ_STRING_LABEL;
                            }
                            CODE_DOUBLE_LITTLE | CODE_DOUBLE_BIG => {
                                v = Val_hp(intern_dest);
                                if !intern_obj_table.is_null() {
                                    let fresh5 = obj_counter;
                                    obj_counter = obj_counter.wrapping_add(1);
                                    *intern_obj_table.offset(fresh5 as isize) = v
                                }
                                *intern_dest = Make_header(Double_wosize, Double_tag, intern_color);
                                intern_dest = intern_dest
                                    .offset((1 as c_int as c_ulong).wrapping_add(Double_wosize)
                                        as isize);
                                readfloat(v as *mut c_double, code);
                                current_block = NOTHING_TO_DO_LABEL;
                            }
                            CODE_DOUBLE_ARRAY8_LITTLE | CODE_DOUBLE_ARRAY8_BIG => {
                                len = read8u() as mlsize_t;
                                current_block = READ_DOUBLE_ARRAY_LABEL;
                            }
                            CODE_DOUBLE_ARRAY32_LITTLE | CODE_DOUBLE_ARRAY32_BIG => {
                                len = read32u() as mlsize_t;
                                current_block = READ_DOUBLE_ARRAY_LABEL;
                            }
                            CODE_DOUBLE_ARRAY64_LITTLE | CODE_DOUBLE_ARRAY64_BIG => {
                                len = read64u();
                                current_block = READ_DOUBLE_ARRAY_LABEL;
                            }
                            CODE_CODEPOINTER => {
                                unimplemented!()
                            }
                            CODE_INFIXPOINTER => {
                                ofs = read32u() as asize_t;
                                sp = PushItem(sp);
                                (*sp).dest = dest;
                                (*sp).op = OShift;
                                (*sp).arg = ofs as intnat;
                                sp = ReadItems(dest, 1, sp);
                                continue;
                            }
                            CODE_CUSTOM | CODE_CUSTOM_LEN | CODE_CUSTOM_FIXED => {
                                unimplemented!()
                            }
                            _ => {
                                intern_cleanup();
                                caml_failwith(
                                    b"input_value: ill-formed message\x00" as *const u8
                                        as *const c_char,
                                );
                            }
                        }
                        match current_block {
                            NOTHING_TO_DO_LABEL => {}
                            READ_BLOCK_LABEL => {}
                            READ_STRING_LABEL => {}
                            _ => {
                                match current_block {
                                    READ_SHARED_LABEL => {
                                        v = *intern_obj_table.offset(obj_counter.wrapping_sub(ofs) as isize)
                                    }
                                    _ /* READ_DOUBLE_ARRAY */ => {
                                        size = len.wrapping_mul(Double_wosize);
                                        v = Val_hp(intern_dest);
                                        if !intern_obj_table.is_null() {
                                            let fresh6 = obj_counter;
                                            obj_counter = obj_counter.wrapping_add(1);
                                            *intern_obj_table.offset(fresh6 as isize) = v
                                        }
                                        *intern_dest = Make_header(size, Double_array_tag, intern_color);
                                        intern_dest = intern_dest.offset((1 as c_int as c_ulong).wrapping_add(size) as isize);
                                        readfloats(v as *mut c_double, len, code);
                                    }
                                }
                                current_block = NOTHING_TO_DO_LABEL;
                            }
                        }
                    }
                    match current_block {
                        NOTHING_TO_DO_LABEL => {}
                        READ_BLOCK_LABEL => {}
                        _ /* READ_STRING_LABEL */ => {
                            size = len
                                .wrapping_add(std::mem::size_of::<value>() as c_ulong)
                                .wrapping_div(std::mem::size_of::<value>() as c_ulong);
                            v = Val_hp(intern_dest);
                            if !intern_obj_table.is_null() {
                                let fresh4 = obj_counter;
                                obj_counter = obj_counter.wrapping_add(1);
                                *intern_obj_table.offset(fresh4 as isize) = v
                            }
                            *intern_dest = Make_header(size, String_tag, intern_color);
                            intern_dest = intern_dest.offset((1 as c_int as c_ulong).wrapping_add(size) as isize);
                            *(Field_ptr_mut(v, (size - 1) as usize)) = 0 as value;
                            ofs_ind = Bsize_wsize(size).wrapping_sub(1 as c_int as c_ulong);
                            *(Byte_ptr_mut(v, ofs_ind as usize)) = ofs_ind.wrapping_sub(len) as c_char;
                            readblock(
                                v as *mut c_char as *const c_char as *mut c_char as *mut c_void,
                                len as intnat,
                            );
                            current_block = NOTHING_TO_DO_LABEL;
                        }
                    }
                }
                match current_block {
                    READ_BLOCK_LABEL => {
                        if size == 0 as c_int as c_ulong {
                            v = Atom(tag as isize)
                        } else {
                            v = Val_hp(intern_dest);
                            if !intern_obj_table.is_null() {
                                let fresh3 = obj_counter;
                                obj_counter = obj_counter.wrapping_add(1);
                                *intern_obj_table.offset(fresh3 as isize) = v
                            }
                            *intern_dest = Make_header(size, tag, intern_color);
                            intern_dest = intern_dest
                                .offset((1 as c_int as c_ulong).wrapping_add(size) as isize);
                            // For objects, we need to freshen the oid
                            if tag == Object_tag {
                                // Request to read rest of the elements of the block
                                sp = ReadItems(
                                    Field_ptr_mut(v, 2),
                                    size.wrapping_sub(2 as c_int as c_ulong) as i64,
                                    sp,
                                );
                                // Request freshing OID
                                sp = PushItem(sp);
                                (*sp).op = OFreshOID;
                                (*sp).dest = v as *mut value;
                                (*sp).arg = 1 as c_int as intnat;
                                // Finally read first two block elements: method table and old OID
                                sp = ReadItems(Field_ptr_mut(v, 0), 2, sp);
                            } else {
                                // If it's not an object then read the conents of the block
                                sp = ReadItems(Field_ptr_mut(v, 0), size as i64, sp);
                            }
                        }
                    }
                    _ => {}
                }
                *dest = v
            }
            _ => {}
        }
    }
    intern_free_stack();
}

unsafe fn intern_alloc(whsize: mlsize_t, num_objects: mlsize_t) {
    let mut wosize: mlsize_t = 0;
    if whsize == 0 {
        return;
    }
    wosize = Wosize_whsize(whsize);
    if wosize > Max_wosize {
        // Round desired size up to next page
        let request: asize_t = ((Bsize_wsize(whsize)
            .wrapping_add(Page_size)
            .wrapping_sub(1 as c_int as c_ulong))
            >> Page_log)
            << Page_log;
        intern_extra_block = caml_alloc_for_heap(request);
        if intern_extra_block.is_null() {
            intern_cleanup();
            caml_raise_out_of_memory();
        }
        intern_color = caml_allocation_color(intern_extra_block as *mut c_void);
        intern_dest = intern_extra_block as *mut header_t
    } else {
        // This is a specialized version of caml_alloc from 'alloc.c'
        if wosize <= Max_young_wosize as c_int as c_ulong {
            if wosize == 0 {
                intern_block = Atom(String_tag as isize);
            } else {
                /*
                #define Setup_for_gc
                #define Restore_after_gc
                Alloc_small_no_track(intern_block, wosize, String_tag);
                #undef Setup_for_gc
                #undef Restore_after_gc
                 */
                (*Caml_state)._young_ptr = (*Caml_state)
                    ._young_ptr
                    .offset(-(wosize.wrapping_add(1 as c_int as c_ulong) as isize));
                if (*Caml_state)._young_ptr < (*Caml_state)._young_limit {
                    caml_alloc_small_dispatch(
                        wosize as intnat,
                        CAML_DONT_TRACK as c_int | CAML_FROM_C as c_int,
                        1 as c_int,
                        std::ptr::null_mut::<c_uchar>(),
                    );
                }
                *((*Caml_state)._young_ptr as *mut header_t) = (wosize << 10 as c_int)
                    .wrapping_add(0 as c_int as c_ulong)
                    .wrapping_add(252 as c_int as tag_t as c_ulong);
                intern_block =
                    ((*Caml_state)._young_ptr as *mut header_t).offset(1 as c_int as isize) as value
            }
        } else {
            intern_block = caml_alloc_shr_no_track_noexc(wosize, 252 as c_int as tag_t);
            // do not do the urgent_gc check here because it might darken
            // intern_block into gray and break the intern_color assertion below
            if intern_block == 0 as c_int as c_long {
                intern_cleanup();
                caml_raise_out_of_memory();
            }
        }
        intern_header = Hd_val(intern_block);
        intern_color = Color_hd(intern_header);
        intern_dest = Hp_val(intern_block);
    }
    obj_counter = 0;
    if num_objects > 0 {
        intern_obj_table = caml_stat_alloc_noexc(
            num_objects.wrapping_mul(std::mem::size_of::<value>() as c_ulong),
        ) as *mut value;
        if intern_obj_table.is_null() {
            intern_cleanup();
            caml_raise_out_of_memory();
        }
    };
}

unsafe fn intern_add_to_heap(whsize: mlsize_t) -> *mut header_t {
    let mut res: *mut header_t = std::ptr::null_mut::<header_t>();
    if !intern_extra_block.is_null() {
        // If heap chunk not filled totally, build free block at end
        let request: asize_t =
            (*(intern_extra_block as *mut heap_chunk_head).offset(-(1 as c_int as isize))).size;
        let end_extra_block: *mut header_t =
            (intern_extra_block as *mut header_t).offset(Wsize_bsize(request) as isize);
        if intern_dest < end_extra_block {
            make_free_blocks(
                intern_dest as *mut value,
                end_extra_block.offset_from(intern_dest) as c_long as mlsize_t,
                0 as c_int,
                Caml_white,
            );
        }
        caml_allocated_words += Wsize_bsize(
            (intern_dest as *mut c_char).offset_from(intern_extra_block) as c_long as c_ulong,
        );
        if caml_add_to_heap(intern_extra_block) != 0 {
            intern_cleanup();
            caml_raise_out_of_memory();
        }
        res = intern_extra_block as *mut header_t;
        intern_extra_block = std::ptr::null_mut::<c_char>() // To prevent intern_cleanup freeing it
    } else if intern_block != 0 {
        res = Hp_val(intern_block);
        intern_block = 0; // To prevent intern_cleanup rewriting its header
    }
    res
}

unsafe fn intern_end(mut res: value, whsize: mlsize_t) -> value {
    let caml__frame: *mut caml__roots_block = (*Caml_state)._local_roots;
    let mut caml__roots_res: caml__roots_block = caml__roots_block {
        next: std::ptr::null_mut::<caml__roots_block>(),
        ntables: 0,
        nitems: 0,
        tables: [std::ptr::null_mut::<value>(); 5],
    };
    caml__roots_res.next = (*Caml_state)._local_roots;
    (*Caml_state)._local_roots = &mut caml__roots_res;
    caml__roots_res.nitems = 1 as c_int as intnat;
    caml__roots_res.ntables = 1 as c_int as intnat;
    caml__roots_res.tables[0 as c_int as usize] = &mut res;
    let caml__dummy_res: c_int = 0 as c_int;

    let block: *mut header_t = intern_add_to_heap(whsize);
    let blockend: *mut header_t = intern_dest;
    intern_cleanup();
    if !block.is_null() {
        caml_memprof_track_interned(block, blockend);
    }
    caml_process_pending_actions();

    let caml__temp_result: value = res;
    (*Caml_state)._local_roots = caml__frame;
    caml__temp_result
}

unsafe fn parse_header(fun_name: *mut c_char, mut h: *mut marshal_header) {
    let mut errmsg: [c_char; 100] = [0; 100];
    (*h).magic = read32u();
    match (*h).magic {
        MAGIC_NUMBER_SMALL => {
            (*h).header_len = 20 as c_int;
            (*h).data_len = read32u() as uintnat;
            (*h).num_objects = read32u() as uintnat;
            read32u();
            (*h).whsize = read32u() as uintnat
        }
        MAGIC_NUMBER_BIG => {
            (*h).header_len = 32 as c_int;
            read32u();
            (*h).data_len = read64u();
            (*h).num_objects = read64u();
            (*h).whsize = read64u()
        }
        _ => {
            errmsg[(std::mem::size_of::<[c_char; 100]>() as c_ulong)
                .wrapping_sub(1 as c_int as c_ulong) as usize] = 0 as c_int as c_char;
            snprintf(
                errmsg.as_mut_ptr() as *mut c_char,
                (std::mem::size_of::<[c_char; 100]>() as c_ulong)
                    .wrapping_sub(1 as c_int as c_ulong) as usize,
                b"%s: bad object\x00" as *const u8 as *const c_char,
                fun_name,
            );
            caml_failwith(errmsg.as_mut_ptr());
        }
    };
}

unsafe fn input_val_from_string(mut str: value, ofs: intnat) -> value {
    let caml__frame: *mut caml__roots_block = (*Caml_state)._local_roots;
    let mut caml__roots_str: caml__roots_block = caml__roots_block {
        next: std::ptr::null_mut::<caml__roots_block>(),
        ntables: 0,
        nitems: 0,
        tables: [std::ptr::null_mut::<value>(); 5],
    };
    caml__roots_str.next = (*Caml_state)._local_roots;
    (*Caml_state)._local_roots = &mut caml__roots_str;
    caml__roots_str.nitems = 1 as c_int as intnat;
    caml__roots_str.ntables = 1 as c_int as intnat;
    caml__roots_str.tables[0 as c_int as usize] = &mut str;
    let caml__dummy_str: c_int = 0 as c_int;
    let mut obj: value = ((0 as c_int as uintnat) << 1 as c_int) as intnat + 1 as c_int as c_long;
    let mut caml__roots_obj: caml__roots_block = caml__roots_block {
        next: std::ptr::null_mut::<caml__roots_block>(),
        ntables: 0,
        nitems: 0,
        tables: [std::ptr::null_mut::<value>(); 5],
    };
    caml__roots_obj.next = (*Caml_state)._local_roots;
    (*Caml_state)._local_roots = &mut caml__roots_obj;
    caml__roots_obj.nitems = 1 as c_int as intnat;
    caml__roots_obj.ntables = 1 as c_int as intnat;
    caml__roots_obj.tables[0 as c_int as usize] = &mut obj;
    let caml__dummy_obj: c_int = 0 as c_int;

    let mut h: marshal_header = marshal_header {
        magic: 0,
        header_len: 0,
        data_len: 0,
        num_objects: 0,
        whsize: 0,
    };
    // Initialize global state
    intern_init(
        Byte_u_ptr_mut(str, ofs as usize) as *mut c_void,
        std::ptr::null_mut::<c_void>(),
    );
    parse_header(
        b"input_val_from_string\x00" as *const u8 as *const c_char as *mut c_char,
        &mut h,
    );
    if ((ofs + h.header_len as c_long) as c_ulong).wrapping_add(h.data_len)
        > caml_string_length(str)
    {
        caml_failwith(b"input_val_from_string: bad length\x00" as *const u8 as *const c_char);
    }
    // Allocate result
    intern_alloc(h.whsize, h.num_objects);
    intern_src =
        &mut *(str as *mut c_uchar).offset((ofs + h.header_len as c_long) as isize) as *mut c_uchar;
    // Fill it in
    intern_rec(&mut obj);

    let caml__temp_result: value = intern_end(obj, h.whsize);
    (*Caml_state)._local_roots = caml__frame;
    caml__temp_result
}

#[no_mangle]
pub unsafe extern "C" fn ocamlrep_marshal_input_value_from_string(str: value, ofs: value) -> value {
    input_val_from_string(str, ofs >> 1 as c_int)
}
