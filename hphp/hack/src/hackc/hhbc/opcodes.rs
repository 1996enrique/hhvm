// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the "hack" directory of this source tree.

use crate::{
    AdataId, BareThisOp, BumpSliceMut, ClassId, ClassNum, CollectionType, ConstId, ContCheckOp,
    FatalOp, FcallArgs, FunctionId, IncDecOp, InitPropOp, IsLogAsDynamicCallOp, IsTypeOp, IterArgs,
    IterId, Label, Local, LocalRange, MOpMode, MemberKey, MethodId, NumParams, OODeclExistsOp,
    ObjMethodOp, ParamId, PropId, QueryMOp, ReadonlyOp, RepoAuthType, SetOpOp, SetRangeOp,
    SilenceOp, Slice, SpecialClsRef, StackIndex, Str, SwitchKind, TypeStructResolveOp,
};

#[derive(Clone, Debug)]
#[repr(C)]
pub enum Opcodes<'arena> {
    AKExists,
    Add,
    AddElemC,
    AddNewElemC,
    AddO,
    ArrayIdx,
    ArrayMarkLegacy,
    ArrayUnmarkLegacy,
    AssertRATL(Local<'arena>, RepoAuthType<'arena>),
    AssertRATStk(StackIndex, RepoAuthType<'arena>),
    Await,
    AwaitAll(LocalRange),
    BareThis(BareThisOp),
    BaseC(StackIndex, MOpMode),
    BaseGC(StackIndex, MOpMode),
    BaseGL(Local<'arena>, MOpMode),
    BaseH,
    BaseL(Local<'arena>, MOpMode, ReadonlyOp),
    BaseSC(StackIndex, StackIndex, MOpMode, ReadonlyOp),
    BitAnd,
    BitNot,
    BitOr,
    BitXor,
    // Break(isize),
    BreakTraceHint,
    CGetCUNop,
    CGetG,
    CGetL(Local<'arena>),
    CGetL2(Local<'arena>),
    CGetQuietL(Local<'arena>),
    CGetS(ReadonlyOp),
    CUGetL(Local<'arena>),
    CastBool,
    CastDict,
    CastDouble,
    CastInt,
    CastKeyset,
    CastString,
    CastVec,
    ChainFaults,
    CheckProp(PropId<'arena>),
    CheckReifiedGenericMismatch,
    CheckThis,
    ClassGetC,
    ClassGetTS,
    ClassName,
    Clone,
    ClsCns(ConstId<'arena>),
    ClsCnsD(ConstId<'arena>, ClassId<'arena>),
    ClsCnsL(Local<'arena>),
    Cmp,
    CnsE(ConstId<'arena>),
    ColFromArray(CollectionType),
    CombineAndResolveTypeStruct(u32),
    // Comment(Str<'arena>),
    Concat,
    ConcatN(u32),
    ContCheck(ContCheckOp),
    ContCurrent,
    ContEnter,
    ContGetReturn,
    ContKey,
    ContRaise,
    ContValid,
    // Continue(isize),
    CreateCl(NumParams, ClassNum),
    CreateCont,
    Dict(AdataId<'arena>),
    Dim(MOpMode, MemberKey<'arena>),
    Dir,
    Div,
    Double(f64),
    Dup,
    EntryNop,
    Eq,
    Eval,
    Exit,
    FCallClsMethod(FcallArgs<'arena>, Str<'arena>, IsLogAsDynamicCallOp),
    FCallClsMethodD(
        FcallArgs<'arena>,
        Str<'arena>,
        ClassId<'arena>,
        MethodId<'arena>,
    ),
    FCallClsMethodS(FcallArgs<'arena>, Str<'arena>, SpecialClsRef),
    FCallClsMethodSD(
        FcallArgs<'arena>,
        Str<'arena>,
        SpecialClsRef,
        MethodId<'arena>,
    ),
    FCallCtor(FcallArgs<'arena>, Str<'arena>),
    FCallFunc(FcallArgs<'arena>),
    FCallFuncD {
        fcall_args: FcallArgs<'arena>,
        func: FunctionId<'arena>,
    },
    FCallObjMethod {
        fcall_args: FcallArgs<'arena>,
        flavor: ObjMethodOp,
    },
    FCallObjMethodD {
        fcall_args: FcallArgs<'arena>,
        flavor: ObjMethodOp,
        method: MethodId<'arena>,
    },
    False,
    Fatal(FatalOp),
    File,
    FuncCred,
    GetMemoKeyL(Local<'arena>),
    Gt,
    Gte,
    Idx,
    IncDecG(IncDecOp),
    IncDecL(Local<'arena>, IncDecOp),
    IncDecM(StackIndex, IncDecOp, MemberKey<'arena>),
    IncDecS(IncDecOp),
    Incl,
    InclOnce,
    InitProp(PropId<'arena>, InitPropOp),
    InstanceOf,
    InstanceOfD(ClassId<'arena>),
    Int(i64),
    IsLateBoundCls,
    IsTypeC(IsTypeOp),
    IsTypeL(Local<'arena>, IsTypeOp),
    IsTypeStructC(TypeStructResolveOp),
    IsUnsetL(Local<'arena>),
    IssetG,
    IssetL(Local<'arena>),
    IssetS,
    IterFree(IterId),
    IterInit(IterArgs<'arena>, Label),
    IterNext(IterArgs<'arena>, Label),
    Jmp(Label),
    JmpNS(Label),
    JmpNZ(Label),
    JmpZ(Label),
    Keyset(AdataId<'arena>),
    // Label(Label),
    LateBoundCls,
    LazyClass(ClassId<'arena>),
    LazyClassFromClass,
    LockObj,
    Lt,
    Lte,
    MemoGet(Label, LocalRange),
    MemoGetEager([Label; 2], LocalRange),
    MemoSet(LocalRange),
    MemoSetEager(LocalRange),
    Method,
    Mod,
    Mul,
    MulO,
    NSame,
    NativeImpl,
    Neq,
    NewCol(CollectionType),
    /// capacity hint
    NewDictArray(u32),
    NewKeysetArray(u32),
    NewObj,
    NewObjD(ClassId<'arena>),
    NewObjR,
    NewObjRD(ClassId<'arena>),
    NewObjS(SpecialClsRef),
    NewPair,
    NewStructDict(Slice<'arena, Str<'arena>>),
    NewVec(u32),
    Nop,
    Not,
    Null,
    NullUninit,
    OODeclExists(OODeclExistsOp),
    ParentCls,
    PopC,
    PopL(Local<'arena>),
    PopU,
    Pow,
    Print,
    PushL(Local<'arena>),
    QueryM(StackIndex, QueryMOp, MemberKey<'arena>),
    RaiseClassStringConversionWarning,
    RecordReifiedGeneric,
    Req,
    ReqDoc,
    ReqOnce,
    ResolveClass(ClassId<'arena>),
    ResolveClsMethod(MethodId<'arena>),
    ResolveClsMethodD(ClassId<'arena>, MethodId<'arena>),
    ResolveClsMethodS(SpecialClsRef, MethodId<'arena>),
    ResolveFunc(FunctionId<'arena>),
    ResolveMethCaller(FunctionId<'arena>),
    ResolveRClsMethod(MethodId<'arena>),
    ResolveRClsMethodD(ClassId<'arena>, MethodId<'arena>),
    ResolveRClsMethodS(SpecialClsRef, MethodId<'arena>),
    ResolveRFunc(FunctionId<'arena>),
    RetC,
    RetCSuspended,
    RetM(StackIndex),
    /// String switch
    SSwitch {
        /// One string for each case.
        cases: BumpSliceMut<'arena, Str<'arena>>,

        /// One Label for each case, congruent to cases.
        targets: BumpSliceMut<'arena, Label>,
    },
    Same,
    SelfCls,
    SetG,
    SetImplicitContextByValue,
    SetL(Local<'arena>),
    SetM(StackIndex, MemberKey<'arena>),
    SetOpG(SetOpOp),
    SetOpL(Local<'arena>, SetOpOp),
    SetOpM(StackIndex, SetOpOp, MemberKey<'arena>),
    SetOpS(SetOpOp),
    SetRangeM(StackIndex, u32, SetRangeOp),
    SetS(ReadonlyOp),
    Shl,
    Shr,
    Silence(Local<'arena>, SilenceOp),
    // SrcLoc(SrcLoc),
    String(Str<'arena>),
    Sub,
    SubO,
    /// Integer switch
    Switch {
        kind: SwitchKind,
        base: i64,
        targets: BumpSliceMut<'arena, Label>,
    },
    This,
    Throw,
    ThrowAsTypeStructException,
    ThrowNonExhaustiveSwitch,
    True,
    // TryCatchBegin,
    // TryCatchEnd,
    // TryCatchMiddle,
    /// Pseudo instruction that will get translated into appropraite literal
    /// bytecode, with possible reference to .adata *)
    // TypedValue(runtime::TypedValue<'arena>),
    UGetCUNop,
    UnsetG,
    UnsetL(Local<'arena>),
    UnsetM(StackIndex, MemberKey<'arena>),
    Vec(AdataId<'arena>),
    VerifyOutType(ParamId<'arena>),
    VerifyParamType(ParamId<'arena>),
    VerifyParamTypeTS(ParamId<'arena>),
    VerifyRetTypeC,
    VerifyRetTypeTS,
    WHResult,
    Yield,
    YieldK,
}
